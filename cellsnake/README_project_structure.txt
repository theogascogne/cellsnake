At its core, CellSnake is accessed through a command-line interface. 
When you run a command like:

cellsnake minimal path/to/data

you're interacting with the Python wrapper script called command_line.py. This script parses your arguments and forwards them to Snakemake, using the central Snakefile to build a dynamic workflow based on your chosen mode and input directory. The Snakefile compiles a list of target output files that Snakemakeâ€™s rule all depends on. This output list is generated by utility functions defined in create_plot_functions.py, found in the workflow_utils folder. That same folder also contains workflow_funcs.py, which detects valid sample names from the provided input directory, and extra_functions.py, which offers common utility support across the other two scripts.

In a sense, Cellsnake's architecture can be split into two based on the programming language used, Python and R.
The "Python-side" is the wrapper command_line.py and the Snakefile since Snakemake's domain specific language (DSL) is python based. You can use Python syntax inside the Snakefile and the .SMK rule files which belongs to Snakemake.

There are ofcourse more than just the command line. Here is a rundown:


---------------------------------------------------------------------
command_line.py:
---------------------------------------------------------------------

The command_line.py script is the main executable for CellSnake and acts as the command-line interface (CLI) entry point for users. When the cellsnake command is called in a terminal, this script is what is executed. It uses the docopt library to define all usage patterns, commands, and arguments, offering a rich interface that supports both basic and advanced options. Users can invoke different workflows such as minimal, standard, advanced, clustree, or integrate, or run special commands like --generate-template, --install-packages, or test routines such as cellsnake test all/coverage or even linting. These are all declared in the large docstring at the top, which functions both as help text and a blueprint for argument parsing. New commands must be declared in the docstring!

----
check_command_line_arguments:

The check_command_line_arguments(arguments) function validates inputs provided to the cellsnake CLI tool, ensuring everything is correctly set up before execution begins. It first checks whether the <INPUT> path exists unless the command is specifically set to 'test'. If the --integrated flag is used, it ensures the input is a valid Seurat .rds file rather than a directory or an invalid file type. It also verifies the existence of critical files such as the configuration file (--configfile) and metadata file (--metadata). If a Kraken database folder is specified (--kraken_db_folder), it ensures the folder exists and contains the necessary inspect.txt file. Finally, if a taxonomy level is provided via --taxa, it checks whether it matches one of the accepted levels (like "species", "genus", etc.). If any of these validations fail, the function prints a descriptive error message and returns False; otherwise, it returns True.
----

----
CommandLine class
The CommandLine class is responsible for constructing a complete snakemake command tailored for running the Cellsnake pipeline. It begins with a base command and appends a randomly generated run ID to help identify the session. It parses user arguments, integrates configuration settings either from a YAML file (--configfile) or directly from the command line, and formats them into Snakemake-friendly key=value pairs. Depending on the mode (--dry, --unlock, --remove, etc.) or input type (e.g., gene files, Kraken DB folder), it adjusts behavior accordingly. It also detects whether the input run is an integration analysis and appends related parameters as needed. After the command is fully assembled, it can optionally write a log detailing the command, configuration, and runtime metrics.
----

----
run_integration(arguments)
The run_integration function is designed to execute an integrated analysis pipeline using Snakemake, though it is currently commented out after the first execution. It initializes a CommandLine object with integration mode enabled, prepares the command using input arguments, and runs the resulting Snakemake command via subprocess.check_call(). It then logs the execution using write_to_log(). The commented-out portion suggests a second run on the already-integrated dataset, possibly for downstream analysis, but it remains disabled for now.
----

----
run_workflow(arguments)
The run_workflow function takes parsed CLI arguments, creates a CommandLine instance, and builds a complete Snakemake command using the given parameters. If the integrated flag is set, it updates internal flags to reflect that this is an integration run. It then executes the built command with os.system(). If the command fails (non-zero exit code), it prints an error; otherwise, it logs the command, its parameters, and execution time using write_to_log().
----

----
main()  (this is also where you want to add more functionalities!)
The main function serves as the entry point of the CLI program. It parses command-line arguments using docopt, then branches into different behaviors based on the input. If the command is test, it checks the submode (all or cover) and runs a mock test. It can also run Snakemake's built-in linter, generate template files (config.yaml and metadata.csv), or install required R packages. Before executing any pipeline, it validates input arguments using check_command_line_arguments(). If validation passes and the command matches a supported operation (like minimal, standard, advanced, etc.), it delegates execution to run_workflow().
----


That is where the wrapper ends.
The 'Python-side' of the project architecture extends beyond this however, since Snakemake uses a Python based DSL. The wrapper already has the Snakefile directory, so the command it runs will execute the Snakefile.


In the scrna workflow that the wrapper currenlty runs, you will find:

Snakefile
-Test folders
-Utility functions folders
-scripts and their respective helper functions written in R
-rule files for snakemake (.SMK)
